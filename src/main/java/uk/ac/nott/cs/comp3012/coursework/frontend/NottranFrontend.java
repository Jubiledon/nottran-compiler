package uk.ac.nott.cs.comp3012.coursework.frontend;

import org.antlr.v4.gui.TreeViewer;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.ParseTree;
import uk.ac.nott.cs.comp3012.coursework.NottscriptLexer;
import uk.ac.nott.cs.comp3012.coursework.NottscriptParser;
import uk.ac.nott.cs.comp3012.coursework.ast.Ast;
import uk.ac.nott.cs.comp3012.coursework.ast.AstPrinter;
import uk.ac.nott.cs.comp3012.coursework.ast.Program;
import uk.ac.nott.cs.comp3012.coursework.semantic.SemanticAnalyser;

import javax.swing.*;
import java.util.Arrays;

public class NottranFrontend implements Frontend{
    @Override
    public Ast runFrontend(String programText) {
        CharStream input = CharStreams.fromString(programText);
        NottscriptLexer lexer = new NottscriptLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        NottscriptParser parser = new NottscriptParser(tokens);
        ParseTree tree = parser.program();

//        renderParseTree(tree, parser);

        // TODO: Write your AST builder visitor
        AstBuilder builder = new AstBuilder();
        Ast ast = builder.visit(tree);

        // print ast
        AstPrinter printer = new AstPrinter();
        printer.print(ast);

        // run semantic analysis
        if (ast instanceof Program p) {
            var analyzer = new SemanticAnalyser();
            var res = analyzer.analyse(p);
            if (res.hasErrors()) {
                res.printErrors();
                // choose whether to stop compilation or continue:
                // - For development: print errors and exit (recommended)
                // - For tolerant mode: continue but be careful
                throw new RuntimeException("Semantic errors detected; aborting compilation");
            } else {
                System.out.println("Semantic analysis: no errors");
            }
        } else {
            throw new RuntimeException("Frontend did not produce Program node");
        }

        return ast;
    }

    /**
     * Prints tokens generated by lexer. Used for debugging.
     * @param tokens
     */
    private void printTokens(CommonTokenStream tokens){
        // Fill the token stream
        tokens.fill();  // ensures all tokens are loaded
        System.out.println("TOKENS:");
        for (Token t : tokens.getTokens()) {
            // Print the token type name and the actual text
            String tokenName = NottscriptLexer.VOCABULARY.getSymbolicName(t.getType());
            System.out.println(tokenName + " : '" + t.getText() + "'");
        }
    }

    /**
     * Displays the GUI for the parse tree generated by the parser. used for debugging.
     * @param tree
     * @param parser
     */
    private void renderParseTree(ParseTree tree, NottscriptParser parser) {
        JFrame frame = new JFrame("Parse Tree");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        TreeViewer viewer = new TreeViewer(Arrays.asList(parser.getRuleNames()), tree);
        viewer.setScale(1.5); // zoom
        frame.add(viewer);
        frame.setSize(800, 600);
        frame.setVisible(true);
    }
}
